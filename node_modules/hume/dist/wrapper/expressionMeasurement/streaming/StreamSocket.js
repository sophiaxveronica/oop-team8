"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StreamSocket = void 0;
const ws_1 = __importDefault(require("ws"));
const uuid_1 = require("uuid");
const StreamingClient_1 = require("./StreamingClient");
const base64Encode_1 = require("../../base64Encode");
const errors = __importStar(require("../../../errors"));
const serializers = __importStar(require("../../../serialization"));
const fs = __importStar(require("fs"));
class StreamSocket {
    constructor({ websocket, config, streamWindowMs }) {
        this.websocket = websocket;
        this.config = config;
        this.streamWindowMs = streamWindowMs;
    }
    /**
     * Send file on the `StreamSocket`
     *
     * @param file A fs.ReadStream | File | Blob
     * @param config This method is intended for use with a `LanguageConfig`.
     * When the socket is configured for other modalities this method will fail.
     */
    sendFile({ file, config, }) {
        var file_1, file_1_1;
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (config != null) {
                this.config = config;
            }
            let contents = "";
            if (file instanceof fs.ReadStream) {
                const chunks = [];
                try {
                    for (file_1 = __asyncValues(file); file_1_1 = yield file_1.next(), !file_1_1.done;) {
                        const chunk = file_1_1.value;
                        chunks.push(Buffer.from(chunk));
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (file_1_1 && !file_1_1.done && (_a = file_1.return)) yield _a.call(file_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                contents = Buffer.concat(chunks).toString("base64");
            }
            else if (file instanceof Blob) {
                const toBase64 = (file) => new Promise((res, err) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => res(reader.result);
                });
                contents = yield toBase64(file);
            }
            else {
                throw new errors.HumeError({ message: `file must be one of ReadStream or Blob.` });
            }
            const request = {
                payloadId: (0, uuid_1.v4)(),
                data: contents,
                models: this.config,
                rawText: false,
            };
            if (this.streamWindowMs != null) {
                request.streamWindowMs = this.streamWindowMs;
            }
            const response = yield this.send(request);
            if (response == null) {
                throw new errors.HumeError({ message: `Received no response after sending file: ${file}` });
            }
            return response;
        });
    }
    /**
     * Send text on the `StreamSocket`
     *
     * @param text Text to send to the language model.
     * @param config This method is intended for use with a `LanguageConfig`.
     * When the socket is configured for other modalities this method will fail.
     */
    sendText({ text, config, }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (config != null) {
                this.config = config;
            }
            const request = {
                payloadId: (0, uuid_1.v4)(),
                data: text,
                rawText: true,
                models: this.config,
            };
            if (this.streamWindowMs != null) {
                request.streamWindowMs = this.streamWindowMs;
            }
            const response = yield this.send(request);
            if (response == null) {
                throw new errors.HumeError({ message: `Received no response after sending text: ${text}` });
            }
            return response;
        });
    }
    /**
     * Send facemesh landmarks on the `StreamSocket`
     *
     * @param landmarks List of landmark points for multiple faces.
     * The shape of this 3-dimensional list should be (n, 478, 3) where n is the number
     * of faces to be processed, 478 is the number of MediaPipe landmarks per face and 3
     * represents the (x, y, z) coordinates of each landmark.
     * @param config List of model configurations.
     * If set these configurations will overwrite existing configurations
     */
    sendFacemesh({ landmarks, config, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = this.sendText({
                text: (0, base64Encode_1.base64Encode)(JSON.stringify(landmarks)),
                config,
            });
            return response;
        });
    }
    /**
     *
     * Reset the streaming sliding window.
     *
     * Call this method when some media has been fully processed and you want to continue using the same
     * streaming connection without leaking context across media samples.
     */
    reset() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.send({
                resetStream: true,
            });
        });
    }
    /**
     *
     * Get details associated with the current streaming connection.
     *
     */
    getJobDetails() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.send({
                jobDetails: true,
            });
        });
    }
    /**
     * Closes the underlying socket.
     */
    close() {
        this.websocket.close();
    }
    send(payload) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.tillSocketOpen();
            const jsonPayload = yield serializers.expressionMeasurement.StreamData.jsonOrThrow(payload, {
                unrecognizedObjectKeys: "strip",
            });
            this.websocket.send(JSON.stringify(jsonPayload));
            const response = yield new Promise((resolve, reject) => {
                this.websocket.addEventListener("message", (event) => {
                    const response = (0, StreamingClient_1.parse)(event.data);
                    resolve(response);
                });
            });
            if (response != null && isError(response)) {
                throw new errors.HumeError({ message: `CODE ${response.code}: ${response.error}` });
            }
            return response;
        });
    }
    tillSocketOpen() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.websocket.readyState === ws_1.default.OPEN) {
                return this.websocket;
            }
            return new Promise((resolve, reject) => {
                this.websocket.addEventListener("open", () => {
                    resolve(this.websocket);
                });
                this.websocket.addEventListener("error", (event) => {
                    reject(event);
                });
            });
        });
    }
}
exports.StreamSocket = StreamSocket;
function isError(response) {
    return response.error != null;
}
