import { CloseEvent } from 'reconnecting-websocket';
import z$1, { z } from 'zod';

declare enum MimeType {
    WEBM = "audio/webm",
    MP4 = "audio/mp4",
    WAV = "audio/wav"
}
declare function arrayBufferToBlob(arrayBuffer: ArrayBuffer, mimeType?: string): Blob;
declare function base64ToBlob(base64: string, contentType: string): Blob;
/**
 * @name getSupportedMimeType
 * @description
 * Returns the supported mime type for the current browser.
 * @returns
 * - `success: true` and `mimeType: MimeType` if the browser supports any of the compatible mime types.
 */
declare function getSupportedMimeType(): {
    success: true;
    mimeType: MimeType;
} | {
    success: false;
    error: Error;
};

declare const SocketConfigSchema: z.ZodObject<{
    hostname: z.ZodString;
    reconnectAttempts: z.ZodDefault<z.ZodOptional<z.ZodNumber>>;
    debug: z.ZodDefault<z.ZodOptional<z.ZodBoolean>>;
    auth: z.ZodUnion<[z.ZodObject<{
        type: z.ZodLiteral<"apiKey">;
        value: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        type: "apiKey";
        value: string;
    }, {
        type: "apiKey";
        value: string;
    }>, z.ZodObject<{
        type: z.ZodLiteral<"accessToken">;
        value: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        type: "accessToken";
        value: string;
    }, {
        type: "accessToken";
        value: string;
    }>]>;
    configId: z.ZodOptional<z.ZodString>;
    configVersion: z.ZodOptional<z.ZodNumber>;
    resumedChatGroupId: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    hostname: string;
    reconnectAttempts: number;
    debug: boolean;
    auth: {
        type: "apiKey";
        value: string;
    } | {
        type: "accessToken";
        value: string;
    };
    configId?: string | undefined;
    configVersion?: number | undefined;
    resumedChatGroupId?: string | undefined;
}, {
    hostname: string;
    auth: {
        type: "apiKey";
        value: string;
    } | {
        type: "accessToken";
        value: string;
    };
    reconnectAttempts?: number | undefined;
    debug?: boolean | undefined;
    configId?: string | undefined;
    configVersion?: number | undefined;
    resumedChatGroupId?: string | undefined;
}>;
type SocketConfig = z.infer<typeof SocketConfigSchema>;
/**
 * @name defaultConfig
 * @description
 * The default configuration for the VoiceClient.
 * @type
 * A configuration object.
 */
declare const defaultConfig: Omit<SocketConfig, 'auth'>;
/**
 * @name createSocketConfig
 * @description
 * Create a new configuration for the VoiceClient.
 * @param config - The configuration for the client.
 * @returns
 * A new configuration instance.
 * @example
 * ```ts
 * const config = createSocketConfig({
 *  auth: {
 *   type: 'apiKey',
 *  value: 'test',
 * },
 * });
 * ```
 */
declare const createSocketConfig: (config: Pick<SocketConfig, 'auth'> & Partial<Omit<SocketConfig, 'auth'>>) => SocketConfig;

declare const AudioMessageSchema: z$1.ZodEffects<z$1.ZodObject<{
    type: z$1.ZodLiteral<"audio">;
    data: z$1.ZodType<ArrayBuffer, z$1.ZodTypeDef, ArrayBuffer>;
}, "strip", z$1.ZodTypeAny, {
    type: "audio";
    data: ArrayBuffer;
}, {
    type: "audio";
    data: ArrayBuffer;
}>, {
    type: "audio";
    data: ArrayBuffer;
} & {
    receivedAt: Date;
}, {
    type: "audio";
    data: ArrayBuffer;
}>;
type AudioMessage = z$1.infer<typeof AudioMessageSchema>;
declare const parseAudioMessage: (blob: Blob) => Promise<AudioMessage | null>;

declare const literalSchema: z$1.ZodUnion<[z$1.ZodString, z$1.ZodNumber, z$1.ZodBoolean, z$1.ZodNull]>;
type Literal = z$1.infer<typeof literalSchema>;
type Json = Literal | {
    [key: string]: Json;
} | Json[];
declare const ToolCallSchema: z$1.ZodEffects<z$1.ZodObject<{
    type: z$1.ZodLiteral<"tool_call">;
    tool_type: z$1.ZodEnum<["builtin", "function"]>;
    tool_call_id: z$1.ZodString;
    response_required: z$1.ZodBoolean;
    name: z$1.ZodString;
    parameters: z$1.ZodString;
}, "strip", z$1.ZodTypeAny, {
    type: "tool_call";
    tool_type: "function" | "builtin";
    tool_call_id: string;
    response_required: boolean;
    name: string;
    parameters: string;
}, {
    type: "tool_call";
    tool_type: "function" | "builtin";
    tool_call_id: string;
    response_required: boolean;
    name: string;
    parameters: string;
}>, {
    type: "tool_call";
    tool_type: "function" | "builtin";
    tool_call_id: string;
    response_required: boolean;
    name: string;
    parameters: string;
} & {
    receivedAt: Date;
}, {
    type: "tool_call";
    tool_type: "function" | "builtin";
    tool_call_id: string;
    response_required: boolean;
    name: string;
    parameters: string;
}>;
type ToolCall = z$1.infer<typeof ToolCallSchema>;
declare const ToolResponseContentSchema: z$1.ZodUnion<[z$1.ZodString, z$1.ZodType<Json, z$1.ZodTypeDef, Json>]>;
type ToolResponseContent = z$1.infer<typeof ToolResponseContentSchema>;
declare const ToolResponseSchema: z$1.ZodObject<{
    type: z$1.ZodLiteral<"tool_response">;
    tool_call_id: z$1.ZodString;
    content: z$1.ZodUnion<[z$1.ZodString, z$1.ZodType<Json, z$1.ZodTypeDef, Json>]>;
    tool_name: z$1.ZodOptional<z$1.ZodString>;
    tool_type: z$1.ZodOptional<z$1.ZodEnum<["builtin", "function"]>>;
}, "strip", z$1.ZodTypeAny, {
    type: "tool_response";
    content: ((string | number | boolean | {
        [key: string]: Json;
    } | Json[]) & (string | number | boolean | {
        [key: string]: Json;
    } | Json[] | undefined)) | null;
    tool_call_id: string;
    tool_name?: string | undefined;
    tool_type?: "function" | "builtin" | undefined;
}, {
    type: "tool_response";
    content: ((string | number | boolean | {
        [key: string]: Json;
    } | Json[]) & (string | number | boolean | {
        [key: string]: Json;
    } | Json[] | undefined)) | null;
    tool_call_id: string;
    tool_name?: string | undefined;
    tool_type?: "function" | "builtin" | undefined;
}>;
type ToolResponse = z$1.infer<typeof ToolResponseSchema>;
declare const ToolErrorSchema: z$1.ZodObject<{
    type: z$1.ZodLiteral<"tool_error">;
    tool_call_id: z$1.ZodString;
    content: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodString>>;
    error: z$1.ZodString;
    code: z$1.ZodString;
    level: z$1.ZodString;
}, "strip", z$1.ZodTypeAny, {
    type: "tool_error";
    error: string;
    code: string;
    tool_call_id: string;
    level: string;
    content?: string | null | undefined;
}, {
    type: "tool_error";
    error: string;
    code: string;
    tool_call_id: string;
    level: string;
    content?: string | null | undefined;
}>;
type ToolError = z$1.infer<typeof ToolErrorSchema>;

declare const JSONMessageSchema: z$1.ZodUnion<[z$1.ZodEffects<z$1.ZodObject<{
    type: z$1.ZodLiteral<"audio_output">;
    id: z$1.ZodString;
    data: z$1.ZodString;
}, "strip", z$1.ZodTypeAny, {
    type: "audio_output";
    data: string;
    id: string;
}, {
    type: "audio_output";
    data: string;
    id: string;
}>, {
    type: "audio_output";
    data: string;
    id: string;
} & {
    receivedAt: Date;
}, {
    type: "audio_output";
    data: string;
    id: string;
}>, z$1.ZodEffects<z$1.ZodObject<{
    type: z$1.ZodLiteral<"assistant_end">;
}, "strip", z$1.ZodTypeAny, {
    type: "assistant_end";
}, {
    type: "assistant_end";
}>, {
    type: "assistant_end";
} & {
    receivedAt: Date;
}, {
    type: "assistant_end";
}>, z$1.ZodEffects<z$1.ZodObject<{
    type: z$1.ZodLiteral<"user_interruption">;
    time: z$1.ZodCatch<z$1.ZodUnion<[z$1.ZodObject<{
        begin: z$1.ZodNumber;
        end: z$1.ZodNumber;
    }, "strip", z$1.ZodTypeAny, {
        begin: number;
        end: number;
    }, {
        begin: number;
        end: number;
    }>, z$1.ZodNumber, z$1.ZodNull]>>;
}, "strip", z$1.ZodTypeAny, {
    type: "user_interruption";
    time: ((number | {
        begin: number;
        end: number;
    }) & (number | {
        begin: number;
        end: number;
    } | undefined)) | null;
}, {
    type: "user_interruption";
    time?: unknown;
}>, {
    type: "user_interruption";
    time: ((number | {
        begin: number;
        end: number;
    }) & (number | {
        begin: number;
        end: number;
    } | undefined)) | null;
} & {
    receivedAt: Date;
}, {
    type: "user_interruption";
    time?: unknown;
}>, z$1.ZodEffects<z$1.ZodObject<{
    type: z$1.ZodLiteral<"user_message">;
    message: z$1.ZodObject<{
        role: z$1.ZodLiteral<"user">;
        content: z$1.ZodString;
    }, "strip", z$1.ZodTypeAny, {
        role: "user";
        content: string;
    }, {
        role: "user";
        content: string;
    }>;
    models: z$1.ZodObject<{
        prosody: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodObject<{
            scores: z$1.ZodRecord<z$1.ZodString, z$1.ZodNumber>;
        }, "strip", z$1.ZodTypeAny, {
            scores: Record<string, number>;
        }, {
            scores: Record<string, number>;
        }>>>;
        time: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodObject<{
            begin: z$1.ZodNumber;
            end: z$1.ZodNumber;
        }, "strip", z$1.ZodTypeAny, {
            begin: number;
            end: number;
        }, {
            begin: number;
            end: number;
        }>>>;
    }, "strip", z$1.ZodTypeAny, {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    }, {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    }>;
    from_text: z$1.ZodCatch<z$1.ZodOptional<z$1.ZodNullable<z$1.ZodBoolean>>>;
}, "strip", z$1.ZodTypeAny, {
    type: "user_message";
    message: {
        role: "user";
        content: string;
    };
    models: {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    };
    from_text?: boolean | null | undefined;
}, {
    type: "user_message";
    message: {
        role: "user";
        content: string;
    };
    models: {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    };
    from_text?: unknown;
}>, {
    type: "user_message";
    message: {
        role: "user";
        content: string;
    };
    models: {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    };
    from_text?: boolean | null | undefined;
} & {
    receivedAt: Date;
}, {
    type: "user_message";
    message: {
        role: "user";
        content: string;
    };
    models: {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    };
    from_text?: unknown;
}>, z$1.ZodEffects<z$1.ZodObject<{
    type: z$1.ZodLiteral<"assistant_message">;
    id: z$1.ZodString;
    message: z$1.ZodObject<{
        role: z$1.ZodLiteral<"assistant">;
        content: z$1.ZodString;
    }, "strip", z$1.ZodTypeAny, {
        role: "assistant";
        content: string;
    }, {
        role: "assistant";
        content: string;
    }>;
    models: z$1.ZodObject<{
        prosody: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodObject<{
            scores: z$1.ZodRecord<z$1.ZodString, z$1.ZodNumber>;
        }, "strip", z$1.ZodTypeAny, {
            scores: Record<string, number>;
        }, {
            scores: Record<string, number>;
        }>>>;
        time: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodObject<{
            begin: z$1.ZodNumber;
            end: z$1.ZodNumber;
        }, "strip", z$1.ZodTypeAny, {
            begin: number;
            end: number;
        }, {
            begin: number;
            end: number;
        }>>>;
    }, "strip", z$1.ZodTypeAny, {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    }, {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    }>;
    from_text: z$1.ZodCatch<z$1.ZodBoolean>;
}, "strip", z$1.ZodTypeAny, {
    type: "assistant_message";
    message: {
        role: "assistant";
        content: string;
    };
    id: string;
    models: {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    };
    from_text: boolean;
}, {
    type: "assistant_message";
    message: {
        role: "assistant";
        content: string;
    };
    id: string;
    models: {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    };
    from_text?: unknown;
}>, {
    type: "assistant_message";
    message: {
        role: "assistant";
        content: string;
    };
    id: string;
    models: {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    };
    from_text: boolean;
} & {
    receivedAt: Date;
}, {
    type: "assistant_message";
    message: {
        role: "assistant";
        content: string;
    };
    id: string;
    models: {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    };
    from_text?: unknown;
}>, z$1.ZodEffects<z$1.ZodObject<{
    type: z$1.ZodLiteral<"error">;
    code: z$1.ZodString;
    slug: z$1.ZodString;
    message: z$1.ZodString;
}, "strip", z$1.ZodTypeAny, {
    type: "error";
    code: string;
    message: string;
    slug: string;
}, {
    type: "error";
    code: string;
    message: string;
    slug: string;
}>, {
    type: "error";
    code: string;
    message: string;
    slug: string;
} & {
    receivedAt: Date;
}, {
    type: "error";
    code: string;
    message: string;
    slug: string;
}>, z$1.ZodEffects<z$1.ZodObject<{
    type: z$1.ZodLiteral<"tool_call">;
    tool_type: z$1.ZodEnum<["builtin", "function"]>;
    tool_call_id: z$1.ZodString;
    response_required: z$1.ZodBoolean;
    name: z$1.ZodString;
    parameters: z$1.ZodString;
}, "strip", z$1.ZodTypeAny, {
    type: "tool_call";
    tool_type: "function" | "builtin";
    tool_call_id: string;
    response_required: boolean;
    name: string;
    parameters: string;
}, {
    type: "tool_call";
    tool_type: "function" | "builtin";
    tool_call_id: string;
    response_required: boolean;
    name: string;
    parameters: string;
}>, {
    type: "tool_call";
    tool_type: "function" | "builtin";
    tool_call_id: string;
    response_required: boolean;
    name: string;
    parameters: string;
} & {
    receivedAt: Date;
}, {
    type: "tool_call";
    tool_type: "function" | "builtin";
    tool_call_id: string;
    response_required: boolean;
    name: string;
    parameters: string;
}>, z$1.ZodObject<{
    type: z$1.ZodLiteral<"tool_error">;
    tool_call_id: z$1.ZodString;
    content: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodString>>;
    error: z$1.ZodString;
    code: z$1.ZodString;
    level: z$1.ZodString;
}, "strip", z$1.ZodTypeAny, {
    type: "tool_error";
    error: string;
    code: string;
    tool_call_id: string;
    level: string;
    content?: string | null | undefined;
}, {
    type: "tool_error";
    error: string;
    code: string;
    tool_call_id: string;
    level: string;
    content?: string | null | undefined;
}>, z$1.ZodObject<{
    type: z$1.ZodLiteral<"tool_response">;
    tool_call_id: z$1.ZodString;
    content: z$1.ZodUnion<[z$1.ZodString, z$1.ZodType<ToolResponseContent, z$1.ZodTypeDef, ToolResponseContent>]>;
    tool_name: z$1.ZodOptional<z$1.ZodString>;
    tool_type: z$1.ZodOptional<z$1.ZodEnum<["builtin", "function"]>>;
}, "strip", z$1.ZodTypeAny, {
    type: "tool_response";
    content: ((string | number | boolean | {
        [key: string]: ToolResponseContent;
    } | ToolResponseContent[]) & (string | number | boolean | {
        [key: string]: ToolResponseContent;
    } | ToolResponseContent[] | undefined)) | null;
    tool_call_id: string;
    tool_name?: string | undefined;
    tool_type?: "function" | "builtin" | undefined;
}, {
    type: "tool_response";
    content: ((string | number | boolean | {
        [key: string]: ToolResponseContent;
    } | ToolResponseContent[]) & (string | number | boolean | {
        [key: string]: ToolResponseContent;
    } | ToolResponseContent[] | undefined)) | null;
    tool_call_id: string;
    tool_name?: string | undefined;
    tool_type?: "function" | "builtin" | undefined;
}>, z$1.ZodEffects<z$1.ZodObject<{
    type: z$1.ZodLiteral<"chat_metadata">;
    chat_id: z$1.ZodString;
    chat_group_id: z$1.ZodString;
}, "strip", z$1.ZodTypeAny, {
    type: "chat_metadata";
    chat_id: string;
    chat_group_id: string;
}, {
    type: "chat_metadata";
    chat_id: string;
    chat_group_id: string;
}>, {
    type: "chat_metadata";
    chat_id: string;
    chat_group_id: string;
} & {
    receivedAt: Date;
}, {
    type: "chat_metadata";
    chat_id: string;
    chat_group_id: string;
}>]>;
type JSONMessage = z$1.infer<typeof JSONMessageSchema>;

declare enum Channels {
    /** Mono */
    MONO = 1,
    /** Stereo */
    STEREO = 2
}
declare enum AudioEncoding {
    /** 16-bit signed little-endian (PCM) */
    LINEAR16 = "linear16",
    /** Ogg Opus */
    OPUS = "opus"
}
declare const WebSearchToolSchema: z$1.ZodObject<{
    name: z$1.ZodLiteral<"web_search">;
    fallback_content: z$1.ZodCatch<z$1.ZodOptional<z$1.ZodNullable<z$1.ZodString>>>;
}, "strip", z$1.ZodTypeAny, {
    name: "web_search";
    fallback_content?: string | null | undefined;
}, {
    name: "web_search";
    fallback_content?: unknown;
}>;
declare const SessionSettingsSchema: z$1.ZodObject<{
    audio: z$1.ZodOptional<z$1.ZodObject<{
        channels: z$1.ZodNativeEnum<typeof Channels>;
        encoding: z$1.ZodNativeEnum<typeof AudioEncoding>;
        sampleRate: z$1.ZodNumber;
    }, "strip", z$1.ZodTypeAny, {
        channels: Channels;
        encoding: AudioEncoding;
        sampleRate: number;
    }, {
        channels: Channels;
        encoding: AudioEncoding;
        sampleRate: number;
    }>>;
    context: z$1.ZodOptional<z$1.ZodObject<{
        text: z$1.ZodString;
        type: z$1.ZodOptional<z$1.ZodEnum<["editable", "persistent", "temporary"]>>;
    }, "strip", z$1.ZodTypeAny, {
        text: string;
        type?: "editable" | "persistent" | "temporary" | undefined;
    }, {
        text: string;
        type?: "editable" | "persistent" | "temporary" | undefined;
    }>>;
    languageModelApiKey: z$1.ZodOptional<z$1.ZodString>;
    customSessionId: z$1.ZodOptional<z$1.ZodString>;
    systemPrompt: z$1.ZodOptional<z$1.ZodString>;
    builtin_tools: z$1.ZodOptional<z$1.ZodArray<z$1.ZodUnion<[z$1.ZodObject<{
        name: z$1.ZodLiteral<"web_search">;
        fallback_content: z$1.ZodCatch<z$1.ZodOptional<z$1.ZodNullable<z$1.ZodString>>>;
    }, "strip", z$1.ZodTypeAny, {
        name: "web_search";
        fallback_content?: string | null | undefined;
    }, {
        name: "web_search";
        fallback_content?: unknown;
    }>, z$1.ZodNull]>, "many">>;
}, "strip", z$1.ZodTypeAny, {
    audio?: {
        channels: Channels;
        encoding: AudioEncoding;
        sampleRate: number;
    } | undefined;
    context?: {
        text: string;
        type?: "editable" | "persistent" | "temporary" | undefined;
    } | undefined;
    languageModelApiKey?: string | undefined;
    customSessionId?: string | undefined;
    systemPrompt?: string | undefined;
    builtin_tools?: ({
        name: "web_search";
        fallback_content?: string | null | undefined;
    } | null)[] | undefined;
}, {
    audio?: {
        channels: Channels;
        encoding: AudioEncoding;
        sampleRate: number;
    } | undefined;
    context?: {
        text: string;
        type?: "editable" | "persistent" | "temporary" | undefined;
    } | undefined;
    languageModelApiKey?: string | undefined;
    customSessionId?: string | undefined;
    systemPrompt?: string | undefined;
    builtin_tools?: ({
        name: "web_search";
        fallback_content?: unknown;
    } | null)[] | undefined;
}>;
type SessionSettings = z$1.infer<typeof SessionSettingsSchema>;

/**
 * @name VoiceEventMap
 * @description
 * The event map for the VoiceClient.
 * @type
 * An object with the following properties:
 * - `open` - The event to run when the socket is opened.
 * - `message` - The event to run when a message is received.
 * - `close` - The event to run when the socket is closed.
 * - `error` - The event to run when an error occurs.
 */
type VoiceEventMap = {
    open?: () => void;
    message?: (message: JSONMessage | AudioMessage) => void;
    close?: (event: CloseEvent) => void;
    error?: (error: Error) => void;
};
declare class VoiceClient {
    private socket;
    private url;
    private eventHandlers;
    private constructor();
    /**
     * @name create
     * @description
     * Create a new VoiceClient.
     * @param config - The configuration for the client.
     * @returns
     * A new VoiceClient instance.
     * @example
     * ```ts
     * const client = VoiceClient.create(config);
     * ```
     */
    static create(config: SocketConfig): VoiceClient;
    /**
     * @name on
     * @description
     * Attach events to the client.
     * @param event - The event to attach to.
     * @param callback - The callback to run when the event is triggered.
     * @returns
     * The VoiceClient instance.
     * @example
     * ```ts
     * const client = VoiceClient.create(config);
     * client.on('open', () => {
     *  console.log('Socket opened');
     * });
     * ```
     */
    on<T extends keyof VoiceEventMap>(event: T, callback: VoiceEventMap[T]): void;
    private handleOpen;
    handleMessage: (event: MessageEvent) => void;
    private handleClose;
    private handleError;
    /**
     * @name connect
     * @description
     * Connect to the websocket.
     */
    connect(): this;
    /**
     * @name disconnect
     * @description
     * Disconnect from the websocket.
     */
    disconnect(): void;
    /**
     * @name sendAudio
     * @description
     * Send audio data to the websocket.
     */
    sendAudio(audioBuffer: ArrayBufferLike): void;
    /**
     * @name sendUserInput
     * @description
     * Send text data to the websocket.
     */
    sendUserInput(text: string): void;
    /**
     * @name sendAssistantInput
     * @description
     * Send text data to the websocket for TTS.
     */
    sendAssistantInput(text: string): void;
    /**
     * @name sendSessionSettings
     * @description
     * Send session settings to the websocket
     */
    sendSessionSettings(sessionSettings: SessionSettings): void;
    /**
     * @name sendToolMessage
     * @description
     * Send tool response to the websocket, e.g. for function calling
     */
    sendToolMessage(toolMessage: ToolResponse | ToolError): void;
    /**
     * @name readyState
     * @description
     * The current ready state of the socket.
     */
    get readyState(): number;
    /**
     * @name sendPauseAssistantMessage
     * @description
     * Send pause assistant message to the websocket. This pauses responses from EVI. Chat history is still saved and sent after resuming.
     */
    sendPauseAssistantMessage(): void;
    /**
     * @name sendResumeAssistantMessage
     * @description
     * Send resume assistant message to the websocket. This resumes responses from EVI. Chat history sent while paused will now be sent.
     */
    sendResumeAssistantMessage(): void;
}

/**
 * @name createSocketUrl
 * @description
 * Create a new socket URL for the VoiceClient.
 * @param config - The configuration for the client.
 * @returns
 * A new socket URL.
 * @example
 * ```ts
 * const url = createSocketUrl(config);
 * ```
 */
declare const createSocketUrl: (config: SocketConfig) => string;

declare class SocketUnknownMessageError extends Error {
    constructor(message?: string);
}
/**
 * @name isSocketUnknownMessageError
 * @description
 * Check if an error is a SocketUnknownMessageError.
 * @param err - The error to check.
 * @returns
 * `true` if the error is a SocketUnknownMessageError.
 * @example
 * ```ts
 * if (isSocketUnknownMessageError(err)) {
 * console.error('Unknown message type');
 * }
 * ```
 */
declare const isSocketUnknownMessageError: (err: unknown) => err is SocketUnknownMessageError;
declare class SocketFailedToParseMessageError extends Error {
    constructor(message?: string);
}
/**
 * @name isSocketFailedToParseMessageError
 * @description
 * Check if an error is a SocketFailedToParseMessageError.
 * @param err - The error to check.
 * @returns
 * `true` if the error is a SocketFailedToParseMessageError.
 * @example
 * ```ts
 * if (isSocketFailedToParseMessageError(err)) {
 * console.error('Failed to parse message from socket');
 * }
 * ```
 */
declare const isSocketFailedToParseMessageError: (err: unknown) => err is SocketFailedToParseMessageError;

/**
 * @name parseMessageData
 * @description
 * Parse the data of a message from the socket.
 * @param data - The data to parse.
 * @returns
 * The parsed message data.
 * @example
 * ```ts
 * const message = await parseMessageData(data);
 * ```
 */
declare const parseMessageData: (data: unknown) => Promise<{
    success: true;
    message: JSONMessage | AudioMessage;
} | {
    success: false;
    error: Error;
}>;
/**
 * @name parseMessageType
 * @description
 * Parse the type of a message from the socket.
 * @param event - The event to parse.
 * @returns
 * The parsed message type.
 * @example
 * ```ts
 * const message = await parseMessageType(event);
 * ```
 */
declare const parseMessageType: (event: MessageEvent) => Promise<{
    success: true;
    message: JSONMessage | AudioMessage;
} | {
    success: false;
    error: Error;
}>;

declare enum TTSService {
    /** Hume's Text-To-Speech */
    DEFAULT = "hume_ai",
    /** ElevenLab's Text-To-Speech */
    ELEVEN_LABS = "eleven_labs",
    /** Play HT's Text-To-Speech */
    PLAY_HT = "play_ht"
}

/**
 * @name getAudioStream
 * @description
 * Get a MediaStream with audio tracks.
 * @returns
 * A new MediaStream with audio tracks.
 */
declare const getAudioStream: () => Promise<MediaStream>;
/**
 * @name checkForAudioTracks
 * @description
 * Check if a MediaStream has audio tracks.
 * @param stream
 * The MediaStream to check
 */
declare const checkForAudioTracks: (stream: MediaStream) => void;

/**
 * Fetches a new access token from the Hume API using the provided API key and Secret key.
 *
 * @param args - The arguments for the request.
 * @returns Promise that resolves to the new access token.
 * @throws If the base64 encoding fails.
 * @throws If the network request fails.
 * @example
 * ```typescript
 * async function getToken() {
 *   const accessToken = await fetchAccessToken({
 *     apiKey: 'test',
 *     secretKey: 'test',
 *   });
 *   console.log(accessToken); // Outputs the access token
 * }
 * ```
 */
declare const fetchAccessToken: (args: {
    apiKey: string;
    secretKey: string;
    host?: string;
}) => Promise<string>;

declare const AssistantEndMessageSchema: z$1.ZodEffects<z$1.ZodObject<{
    type: z$1.ZodLiteral<"assistant_end">;
}, "strip", z$1.ZodTypeAny, {
    type: "assistant_end";
}, {
    type: "assistant_end";
}>, {
    type: "assistant_end";
} & {
    receivedAt: Date;
}, {
    type: "assistant_end";
}>;
type AssistantEndMessage = z$1.infer<typeof AssistantEndMessageSchema>;

declare const AssistantTranscriptMessageSchema: z$1.ZodEffects<z$1.ZodObject<{
    type: z$1.ZodLiteral<"assistant_message">;
    id: z$1.ZodString;
    message: z$1.ZodObject<{
        role: z$1.ZodLiteral<"assistant">;
        content: z$1.ZodString;
    }, "strip", z$1.ZodTypeAny, {
        role: "assistant";
        content: string;
    }, {
        role: "assistant";
        content: string;
    }>;
    models: z$1.ZodObject<{
        prosody: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodObject<{
            scores: z$1.ZodRecord<z$1.ZodString, z$1.ZodNumber>;
        }, "strip", z$1.ZodTypeAny, {
            scores: Record<string, number>;
        }, {
            scores: Record<string, number>;
        }>>>;
        time: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodObject<{
            begin: z$1.ZodNumber;
            end: z$1.ZodNumber;
        }, "strip", z$1.ZodTypeAny, {
            begin: number;
            end: number;
        }, {
            begin: number;
            end: number;
        }>>>;
    }, "strip", z$1.ZodTypeAny, {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    }, {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    }>;
    from_text: z$1.ZodCatch<z$1.ZodBoolean>;
}, "strip", z$1.ZodTypeAny, {
    type: "assistant_message";
    message: {
        role: "assistant";
        content: string;
    };
    id: string;
    models: {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    };
    from_text: boolean;
}, {
    type: "assistant_message";
    message: {
        role: "assistant";
        content: string;
    };
    id: string;
    models: {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    };
    from_text?: unknown;
}>, {
    type: "assistant_message";
    message: {
        role: "assistant";
        content: string;
    };
    id: string;
    models: {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    };
    from_text: boolean;
} & {
    receivedAt: Date;
}, {
    type: "assistant_message";
    message: {
        role: "assistant";
        content: string;
    };
    id: string;
    models: {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    };
    from_text?: unknown;
}>;
type AssistantTranscriptMessage = z$1.infer<typeof AssistantTranscriptMessageSchema>;

declare const AudioOutputMessageSchema: z.ZodEffects<z.ZodObject<{
    type: z.ZodLiteral<"audio_output">;
    id: z.ZodString;
    data: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "audio_output";
    data: string;
    id: string;
}, {
    type: "audio_output";
    data: string;
    id: string;
}>, {
    type: "audio_output";
    data: string;
    id: string;
} & {
    receivedAt: Date;
}, {
    type: "audio_output";
    data: string;
    id: string;
}>;
type AudioOutputMessage = z.infer<typeof AudioOutputMessageSchema>;

declare const AuthStrategySchema: z$1.ZodUnion<[z$1.ZodObject<{
    type: z$1.ZodLiteral<"apiKey">;
    value: z$1.ZodString;
}, "strip", z$1.ZodTypeAny, {
    type: "apiKey";
    value: string;
}, {
    type: "apiKey";
    value: string;
}>, z$1.ZodObject<{
    type: z$1.ZodLiteral<"accessToken">;
    value: z$1.ZodString;
}, "strip", z$1.ZodTypeAny, {
    type: "accessToken";
    value: string;
}, {
    type: "accessToken";
    value: string;
}>]>;
type AuthStrategy = z$1.infer<typeof AuthStrategySchema>;

declare const ChatMetadataMessageSchema: z$1.ZodEffects<z$1.ZodObject<{
    type: z$1.ZodLiteral<"chat_metadata">;
    chat_id: z$1.ZodString;
    chat_group_id: z$1.ZodString;
}, "strip", z$1.ZodTypeAny, {
    type: "chat_metadata";
    chat_id: string;
    chat_group_id: string;
}, {
    type: "chat_metadata";
    chat_id: string;
    chat_group_id: string;
}>, {
    type: "chat_metadata";
    chat_id: string;
    chat_group_id: string;
} & {
    receivedAt: Date;
}, {
    type: "chat_metadata";
    chat_id: string;
    chat_group_id: string;
}>;
type ChatMetadataMessage = z$1.infer<typeof ChatMetadataMessageSchema>;

declare const JSONErrorMessageSchema: z.ZodEffects<z.ZodObject<{
    type: z.ZodLiteral<"error">;
    code: z.ZodString;
    slug: z.ZodString;
    message: z.ZodString;
}, "strip", z.ZodTypeAny, {
    type: "error";
    code: string;
    message: string;
    slug: string;
}, {
    type: "error";
    code: string;
    message: string;
    slug: string;
}>, {
    type: "error";
    code: string;
    message: string;
    slug: string;
} & {
    receivedAt: Date;
}, {
    type: "error";
    code: string;
    message: string;
    slug: string;
}>;
type JSONErrorMessage = z.infer<typeof JSONErrorMessageSchema>;

declare const TimeSliceSchema: z.ZodObject<{
    begin: z.ZodNumber;
    end: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    begin: number;
    end: number;
}, {
    begin: number;
    end: number;
}>;
type TimeSlice = z.infer<typeof TimeSliceSchema>;

declare const EmotionScoresSchema: z$1.ZodRecord<z$1.ZodString, z$1.ZodNumber>;
type EmotionScores = z$1.infer<typeof EmotionScoresSchema>;
declare const TranscriptModelsSchema: z$1.ZodObject<{
    prosody: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodObject<{
        scores: z$1.ZodRecord<z$1.ZodString, z$1.ZodNumber>;
    }, "strip", z$1.ZodTypeAny, {
        scores: Record<string, number>;
    }, {
        scores: Record<string, number>;
    }>>>;
    time: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodObject<{
        begin: z$1.ZodNumber;
        end: z$1.ZodNumber;
    }, "strip", z$1.ZodTypeAny, {
        begin: number;
        end: number;
    }, {
        begin: number;
        end: number;
    }>>>;
}, "strip", z$1.ZodTypeAny, {
    prosody?: {
        scores: Record<string, number>;
    } | null | undefined;
    time?: {
        begin: number;
        end: number;
    } | null | undefined;
}, {
    prosody?: {
        scores: Record<string, number>;
    } | null | undefined;
    time?: {
        begin: number;
        end: number;
    } | null | undefined;
}>;

declare const UserInterruptionMessageSchema: z$1.ZodEffects<z$1.ZodObject<{
    type: z$1.ZodLiteral<"user_interruption">;
    time: z$1.ZodCatch<z$1.ZodUnion<[z$1.ZodObject<{
        begin: z$1.ZodNumber;
        end: z$1.ZodNumber;
    }, "strip", z$1.ZodTypeAny, {
        begin: number;
        end: number;
    }, {
        begin: number;
        end: number;
    }>, z$1.ZodNumber, z$1.ZodNull]>>;
}, "strip", z$1.ZodTypeAny, {
    type: "user_interruption";
    time: ((number | {
        begin: number;
        end: number;
    }) & (number | {
        begin: number;
        end: number;
    } | undefined)) | null;
}, {
    type: "user_interruption";
    time?: unknown;
}>, {
    type: "user_interruption";
    time: ((number | {
        begin: number;
        end: number;
    }) & (number | {
        begin: number;
        end: number;
    } | undefined)) | null;
} & {
    receivedAt: Date;
}, {
    type: "user_interruption";
    time?: unknown;
}>;
type UserInterruptionMessage = z$1.infer<typeof UserInterruptionMessageSchema>;

declare const UserTranscriptMessageSchema: z$1.ZodEffects<z$1.ZodObject<{
    type: z$1.ZodLiteral<"user_message">;
    message: z$1.ZodObject<{
        role: z$1.ZodLiteral<"user">;
        content: z$1.ZodString;
    }, "strip", z$1.ZodTypeAny, {
        role: "user";
        content: string;
    }, {
        role: "user";
        content: string;
    }>;
    models: z$1.ZodObject<{
        prosody: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodObject<{
            scores: z$1.ZodRecord<z$1.ZodString, z$1.ZodNumber>;
        }, "strip", z$1.ZodTypeAny, {
            scores: Record<string, number>;
        }, {
            scores: Record<string, number>;
        }>>>;
        time: z$1.ZodOptional<z$1.ZodNullable<z$1.ZodObject<{
            begin: z$1.ZodNumber;
            end: z$1.ZodNumber;
        }, "strip", z$1.ZodTypeAny, {
            begin: number;
            end: number;
        }, {
            begin: number;
            end: number;
        }>>>;
    }, "strip", z$1.ZodTypeAny, {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    }, {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    }>;
    from_text: z$1.ZodCatch<z$1.ZodOptional<z$1.ZodNullable<z$1.ZodBoolean>>>;
}, "strip", z$1.ZodTypeAny, {
    type: "user_message";
    message: {
        role: "user";
        content: string;
    };
    models: {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    };
    from_text?: boolean | null | undefined;
}, {
    type: "user_message";
    message: {
        role: "user";
        content: string;
    };
    models: {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    };
    from_text?: unknown;
}>, {
    type: "user_message";
    message: {
        role: "user";
        content: string;
    };
    models: {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    };
    from_text?: boolean | null | undefined;
} & {
    receivedAt: Date;
}, {
    type: "user_message";
    message: {
        role: "user";
        content: string;
    };
    models: {
        prosody?: {
            scores: Record<string, number>;
        } | null | undefined;
        time?: {
            begin: number;
            end: number;
        } | null | undefined;
    };
    from_text?: unknown;
}>;
type UserTranscriptMessage = z$1.infer<typeof UserTranscriptMessageSchema>;

declare enum LanguageModelOption {
    CLAUDE_3_OPUS = "CLAUDE_3_OPUS",
    CLAUDE_3_SONNET = "CLAUDE_3_SONNET",
    CLAUDE_3_HAIKU = "CLAUDE_3_HAIKU",
    CLAUDE_21 = "CLAUDE_21",
    CLAUDE_INSTANT_12 = "CLAUDE_INSTANT_12",
    GPT_4_TURBO_PREVIEW = "GPT_4_TURBO_PREVIEW",
    GPT_35_TURBO_0125 = "GPT_35_TURBO_0125",
    GPT_35_TURBO = "GPT_35_TURBO",
    FIREWORKS_MIXTRAL_8X7B = "FIREWORKS_MIXTRAL_8X7B"
}

export { type AssistantEndMessage, AssistantEndMessageSchema, type AssistantTranscriptMessage, AssistantTranscriptMessageSchema, AudioEncoding, type AudioMessage, AudioMessageSchema, type AudioOutputMessage, AudioOutputMessageSchema, type AuthStrategy, AuthStrategySchema, Channels, type ChatMetadataMessage, ChatMetadataMessageSchema, type EmotionScores, EmotionScoresSchema, type JSONErrorMessage, JSONErrorMessageSchema, type JSONMessage, JSONMessageSchema, LanguageModelOption, MimeType, type SessionSettings, SessionSettingsSchema, type SocketConfig, SocketConfigSchema, SocketFailedToParseMessageError, SocketUnknownMessageError, TTSService, type TimeSlice, TimeSliceSchema, type ToolCall, ToolCallSchema, type ToolError, ToolErrorSchema, type ToolResponse, type ToolResponseContent, ToolResponseContentSchema, ToolResponseSchema, TranscriptModelsSchema, type UserInterruptionMessage, UserInterruptionMessageSchema, type UserTranscriptMessage, UserTranscriptMessageSchema, VoiceClient, type VoiceEventMap, WebSearchToolSchema, arrayBufferToBlob, base64ToBlob, checkForAudioTracks, createSocketConfig, createSocketUrl, defaultConfig, fetchAccessToken, getAudioStream, getSupportedMimeType, isSocketFailedToParseMessageError, isSocketUnknownMessageError, parseAudioMessage, parseMessageData, parseMessageType };
