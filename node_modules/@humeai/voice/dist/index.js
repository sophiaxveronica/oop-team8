"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AssistantEndMessageSchema: () => AssistantEndMessageSchema,
  AssistantTranscriptMessageSchema: () => AssistantTranscriptMessageSchema,
  AudioEncoding: () => AudioEncoding,
  AudioMessageSchema: () => AudioMessageSchema,
  AudioOutputMessageSchema: () => AudioOutputMessageSchema,
  AuthStrategySchema: () => AuthStrategySchema,
  Channels: () => Channels,
  ChatMetadataMessageSchema: () => ChatMetadataMessageSchema,
  EmotionScoresSchema: () => EmotionScoresSchema,
  JSONErrorMessageSchema: () => JSONErrorMessageSchema,
  JSONMessageSchema: () => JSONMessageSchema,
  LanguageModelOption: () => LanguageModelOption,
  MimeType: () => MimeType,
  SessionSettingsSchema: () => SessionSettingsSchema,
  SocketConfigSchema: () => SocketConfigSchema,
  SocketFailedToParseMessageError: () => SocketFailedToParseMessageError,
  SocketUnknownMessageError: () => SocketUnknownMessageError,
  TTSService: () => TTSService,
  TimeSliceSchema: () => TimeSliceSchema,
  ToolCallSchema: () => ToolCallSchema,
  ToolErrorSchema: () => ToolErrorSchema,
  ToolResponseContentSchema: () => ToolResponseContentSchema,
  ToolResponseSchema: () => ToolResponseSchema,
  TranscriptModelsSchema: () => TranscriptModelsSchema,
  UserInterruptionMessageSchema: () => UserInterruptionMessageSchema,
  UserTranscriptMessageSchema: () => UserTranscriptMessageSchema,
  VoiceClient: () => VoiceClient,
  WebSearchToolSchema: () => WebSearchToolSchema,
  arrayBufferToBlob: () => arrayBufferToBlob,
  base64ToBlob: () => base64ToBlob,
  checkForAudioTracks: () => checkForAudioTracks,
  createSocketConfig: () => createSocketConfig,
  createSocketUrl: () => createSocketUrl,
  defaultConfig: () => defaultConfig,
  fetchAccessToken: () => fetchAccessToken,
  getAudioStream: () => getAudioStream,
  getSupportedMimeType: () => getSupportedMimeType,
  isSocketFailedToParseMessageError: () => isSocketFailedToParseMessageError,
  isSocketUnknownMessageError: () => isSocketUnknownMessageError,
  parseAudioMessage: () => parseAudioMessage,
  parseMessageData: () => parseMessageData,
  parseMessageType: () => parseMessageType
});
module.exports = __toCommonJS(src_exports);

// src/lib/audio.ts
var MimeType = /* @__PURE__ */ ((MimeType2) => {
  MimeType2["WEBM"] = "audio/webm";
  MimeType2["MP4"] = "audio/mp4";
  MimeType2["WAV"] = "audio/wav";
  return MimeType2;
})(MimeType || {});
function arrayBufferToBlob(arrayBuffer, mimeType) {
  return new Blob([arrayBuffer], { type: mimeType });
}
function base64ToBlob(base64, contentType) {
  const binaryString = window.atob(base64);
  const bytes = new Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  const byteArray = new Uint8Array(bytes);
  return new Blob([byteArray], { type: contentType });
}
function getSupportedMimeType() {
  if (typeof MediaRecorder === "undefined") {
    return {
      success: false,
      error: new Error("MediaRecorder is not supported")
    };
  }
  if (MediaRecorder.isTypeSupported("audio/webm" /* WEBM */)) {
    return { success: true, mimeType: "audio/webm" /* WEBM */ };
  }
  if (MediaRecorder.isTypeSupported("audio/mp4" /* MP4 */)) {
    return { success: true, mimeType: "audio/mp4" /* MP4 */ };
  }
  if (MediaRecorder.isTypeSupported("audio/wav" /* WAV */)) {
    return { success: true, mimeType: "audio/wav" /* WAV */ };
  }
  return {
    success: false,
    error: new Error("Browser does not support any compatible mime types")
  };
}

// src/lib/client.ts
var import_reconnecting_websocket = __toESM(require("reconnecting-websocket"));
var import_snakecase_keys = __toESM(require("snakecase-keys"));

// src/lib/create-url.ts
var createSocketUrl = (config) => {
  const url = new URL(`wss://${config.hostname}`);
  url.pathname = "/v0/evi/chat";
  if (config.auth.type === "accessToken") {
    url.searchParams.set("accessToken", config.auth.value);
  } else if (config.auth.type === "apiKey") {
    url.searchParams.set("apiKey", config.auth.value);
  }
  if (config.configId) {
    url.searchParams.set("config_id", config.configId);
  }
  if (config.configVersion) {
    url.searchParams.set("config_version", String(config.configVersion));
  }
  if (config.resumedChatGroupId) {
    url.searchParams.set(
      "resumed_chat_group_id",
      String(config.resumedChatGroupId)
    );
  }
  return url.href;
};

// src/lib/errors.ts
var SocketUnknownMessageError = class extends Error {
  constructor(message) {
    super(`Unknown message type.${message ? " " + message : ""}`);
    this.name = "SocketUnknownMessageError";
  }
};
var isSocketUnknownMessageError = (err) => {
  return err instanceof SocketUnknownMessageError;
};
var SocketFailedToParseMessageError = class extends Error {
  constructor(message) {
    super(
      `Failed to parse message from socket.${message ? " " + message : ""}`
    );
    this.name = "SocketFailedToParseMessageError";
  }
};
var isSocketFailedToParseMessageError = (err) => {
  return err instanceof SocketFailedToParseMessageError;
};

// src/models/audio-message.ts
var import_zod = __toESM(require("zod"));
var AudioMessageSchema = import_zod.default.object({
  type: import_zod.default.literal("audio"),
  data: import_zod.default.instanceof(ArrayBuffer)
}).transform((obj) => {
  return Object.assign(obj, {
    receivedAt: /* @__PURE__ */ new Date()
  });
});
var parseAudioMessage = async (blob) => {
  return blob.arrayBuffer().then((buffer) => {
    return {
      type: "audio",
      data: buffer,
      receivedAt: /* @__PURE__ */ new Date()
    };
  }).catch(() => {
    return null;
  });
};

// src/models/json-message.ts
var import_zod12 = __toESM(require("zod"));

// src/models/assistant-end-message.ts
var import_zod2 = __toESM(require("zod"));
var AssistantEndMessageSchema = import_zod2.default.object({
  type: import_zod2.default.literal("assistant_end")
}).transform((obj) => {
  return Object.assign(obj, {
    receivedAt: /* @__PURE__ */ new Date()
  });
});

// src/models/assistant-message.ts
var import_zod4 = __toESM(require("zod"));

// src/models/transcript-models.ts
var import_zod3 = __toESM(require("zod"));
var EmotionScoresSchema = import_zod3.default.record(import_zod3.default.string(), import_zod3.default.number());
var TranscriptModelsSchema = import_zod3.default.object({
  // prosody scores are null when the message is not audio
  // (e.g. text input from the user)
  prosody: import_zod3.default.object({
    scores: EmotionScoresSchema
  }).nullish(),
  time: import_zod3.default.object({
    begin: import_zod3.default.number(),
    end: import_zod3.default.number()
  }).nullish()
});

// src/models/assistant-message.ts
var AssistantTranscriptMessageSchema = import_zod4.default.object({
  type: import_zod4.default.literal("assistant_message"),
  id: import_zod4.default.string(),
  message: import_zod4.default.object({
    role: import_zod4.default.literal("assistant"),
    content: import_zod4.default.string()
  }),
  models: TranscriptModelsSchema,
  from_text: import_zod4.default.boolean().catch(false)
}).transform((obj) => {
  return Object.assign(obj, {
    receivedAt: /* @__PURE__ */ new Date()
  });
});

// src/models/audio-output-message.ts
var import_zod5 = require("zod");
var AudioOutputMessageSchema = import_zod5.z.object({
  type: import_zod5.z.literal("audio_output"),
  id: import_zod5.z.string(),
  data: import_zod5.z.string()
}).transform((obj) => {
  return Object.assign(obj, {
    receivedAt: /* @__PURE__ */ new Date()
  });
});

// src/models/chat-metadata-message.ts
var import_zod6 = __toESM(require("zod"));
var ChatMetadataMessageSchema = import_zod6.default.object({
  type: import_zod6.default.literal("chat_metadata"),
  chat_id: import_zod6.default.string(),
  chat_group_id: import_zod6.default.string()
}).transform((obj) => {
  return Object.assign(obj, {
    receivedAt: /* @__PURE__ */ new Date()
  });
});

// src/models/error-message.ts
var import_zod7 = require("zod");
var JSONErrorMessageSchema = import_zod7.z.object({
  type: import_zod7.z.literal("error"),
  code: import_zod7.z.string(),
  slug: import_zod7.z.string(),
  message: import_zod7.z.string()
}).transform((obj) => {
  return Object.assign(obj, {
    receivedAt: /* @__PURE__ */ new Date()
  });
});

// src/models/tool-messages.ts
var import_zod8 = __toESM(require("zod"));
var literalSchema = import_zod8.default.union([import_zod8.default.string(), import_zod8.default.number(), import_zod8.default.boolean(), import_zod8.default.null()]);
var jsonSchema = import_zod8.default.lazy(
  () => import_zod8.default.union([literalSchema, import_zod8.default.array(jsonSchema), import_zod8.default.record(jsonSchema)])
);
var ToolCallSchema = import_zod8.default.object({
  type: import_zod8.default.literal("tool_call"),
  tool_type: import_zod8.default.enum(["builtin", "function"]),
  tool_call_id: import_zod8.default.string(),
  response_required: import_zod8.default.boolean(),
  name: import_zod8.default.string(),
  parameters: import_zod8.default.string()
}).transform((obj) => {
  return Object.assign(obj, {
    receivedAt: /* @__PURE__ */ new Date()
  });
});
var ToolResponseContentSchema = import_zod8.default.union([import_zod8.default.string(), jsonSchema]);
var ToolResponseSchema = import_zod8.default.object({
  type: import_zod8.default.literal("tool_response"),
  tool_call_id: import_zod8.default.string(),
  content: ToolResponseContentSchema,
  tool_name: import_zod8.default.string().optional(),
  tool_type: import_zod8.default.enum(["builtin", "function"]).optional()
});
var ToolErrorSchema = import_zod8.default.object({
  type: import_zod8.default.literal("tool_error"),
  tool_call_id: import_zod8.default.string(),
  content: import_zod8.default.string().nullish(),
  error: import_zod8.default.string(),
  code: import_zod8.default.string(),
  level: import_zod8.default.string()
});

// src/models/user-interruption-message.ts
var import_zod10 = __toESM(require("zod"));

// src/models/time-slice.ts
var import_zod9 = require("zod");
var TimeSliceSchema = import_zod9.z.object({
  begin: import_zod9.z.number(),
  end: import_zod9.z.number()
});

// src/models/user-interruption-message.ts
var UserInterruptionMessageSchema = import_zod10.default.object({
  type: import_zod10.default.literal("user_interruption"),
  time: import_zod10.default.union([TimeSliceSchema, import_zod10.default.number(), import_zod10.default.null()]).catch(null)
}).transform((obj) => {
  return Object.assign(obj, {
    receivedAt: /* @__PURE__ */ new Date()
  });
});

// src/models/user-message.ts
var import_zod11 = __toESM(require("zod"));
var UserTranscriptMessageSchema = import_zod11.default.object({
  type: import_zod11.default.literal("user_message"),
  message: import_zod11.default.object({
    role: import_zod11.default.literal("user"),
    content: import_zod11.default.string()
  }),
  models: TranscriptModelsSchema,
  from_text: import_zod11.default.boolean().nullish().catch(false)
}).transform((obj) => {
  return Object.assign(obj, {
    receivedAt: /* @__PURE__ */ new Date()
  });
});

// src/models/json-message.ts
var JSONMessageSchema = import_zod12.default.union([
  AudioOutputMessageSchema,
  AssistantEndMessageSchema,
  UserInterruptionMessageSchema,
  UserTranscriptMessageSchema,
  AssistantTranscriptMessageSchema,
  JSONErrorMessageSchema,
  ToolCallSchema,
  ToolErrorSchema,
  ToolResponseSchema,
  ChatMetadataMessageSchema
]);

// src/utils/safeJson.ts
var safeJson = (input) => {
  try {
    return { success: true, data: JSON.parse(input) };
  } catch (e) {
    return { success: false };
  }
};

// src/utils/unwrapJson.ts
var unwrapJson = (input, schema) => {
  const json = safeJson(input);
  if (!json.success) {
    return null;
  }
  const message = schema.safeParse(json.data);
  if (!message.success) {
    return null;
  }
  return message.data;
};

// src/lib/message.ts
var parseMessageData = async (data) => {
  if (data instanceof Blob) {
    const message = await parseAudioMessage(data);
    if (message) {
      return {
        success: true,
        message
      };
    } else {
      return {
        success: false,
        error: new SocketFailedToParseMessageError(
          `Received blob was unable to be converted to ArrayBuffer.`
        )
      };
    }
  }
  if (typeof data !== "string") {
    return {
      success: false,
      error: new SocketFailedToParseMessageError(
        `Expected a string but received ${typeof data}.`
      )
    };
  }
  const obj = unwrapJson(data, JSONMessageSchema);
  if (obj === null) {
    return {
      success: false,
      error: new SocketUnknownMessageError(
        `Received JSON was not a known message type.`
      )
    };
  }
  return {
    success: true,
    message: obj
  };
};
var parseMessageType = async (event) => {
  const data = event.data;
  return parseMessageData(data);
};

// src/lib/client.ts
var VoiceClient = class _VoiceClient {
  socket;
  url;
  eventHandlers = {};
  constructor(config) {
    this.url = createSocketUrl(config);
    this.socket = new import_reconnecting_websocket.default(this.url, [], {
      startClosed: true,
      maxRetries: config.reconnectAttempts,
      debug: config.debug
    });
  }
  /**
   * @name create
   * @description
   * Create a new VoiceClient.
   * @param config - The configuration for the client.
   * @returns
   * A new VoiceClient instance.
   * @example
   * ```ts
   * const client = VoiceClient.create(config);
   * ```
   */
  static create(config) {
    return new _VoiceClient(config);
  }
  /**
   * @name on
   * @description
   * Attach events to the client.
   * @param event - The event to attach to.
   * @param callback - The callback to run when the event is triggered.
   * @returns
   * The VoiceClient instance.
   * @example
   * ```ts
   * const client = VoiceClient.create(config);
   * client.on('open', () => {
   *  console.log('Socket opened');
   * });
   * ```
   */
  on(event, callback) {
    this.eventHandlers[event] = callback;
  }
  handleOpen = () => {
    this.eventHandlers.open?.();
  };
  handleMessage = (event) => {
    void parseMessageType(event).then((result) => {
      if (result.success) {
        this.eventHandlers.message?.(result.message);
      }
    });
  };
  handleClose = (event) => {
    this.eventHandlers.close?.(event);
  };
  handleError = (e) => {
    const message = e.message ?? "WebSocket error";
    this.eventHandlers.error?.(new Error(message));
  };
  /**
   * @name connect
   * @description
   * Connect to the websocket.
   */
  connect() {
    this.socket.reconnect();
    this.socket.addEventListener("open", this.handleOpen);
    this.socket.addEventListener("message", this.handleMessage);
    this.socket.addEventListener("close", this.handleClose);
    this.socket.addEventListener("error", this.handleError);
    return this;
  }
  /**
   * @name disconnect
   * @description
   * Disconnect from the websocket.
   */
  disconnect() {
    this.socket?.close();
    this.handleClose({ code: 1e3 });
    this.socket.removeEventListener("open", this.handleOpen);
    this.socket.removeEventListener("message", this.handleMessage);
    this.socket.removeEventListener("close", this.handleClose);
    this.socket.removeEventListener("error", this.handleError);
  }
  /**
   * @name sendAudio
   * @description
   * Send audio data to the websocket.
   */
  sendAudio(audioBuffer) {
    if (!this.socket) {
      throw new Error("Socket is not connected.");
    }
    if (this.socket.readyState !== WebSocket.OPEN) {
      throw new Error("Socket is not open.");
    }
    this.socket.send(audioBuffer);
  }
  /**
   * @name sendUserInput
   * @description
   * Send text data to the websocket.
   */
  sendUserInput(text) {
    if (!this.socket) {
      throw new Error("Socket is not connected.");
    }
    if (this.socket.readyState !== WebSocket.OPEN) {
      throw new Error("Socket is not open.");
    }
    const json = JSON.stringify({ text, type: "user_input" });
    this.socket.send(json);
  }
  /**
   * @name sendAssistantInput
   * @description
   * Send text data to the websocket for TTS.
   */
  sendAssistantInput(text) {
    if (!this.socket) {
      throw new Error("Socket is not connected.");
    }
    if (this.socket.readyState !== WebSocket.OPEN) {
      throw new Error("Socket is not open.");
    }
    const json = JSON.stringify({ text, type: "assistant_input" });
    this.socket.send(json);
  }
  /**
   * @name sendSessionSettings
   * @description
   * Send session settings to the websocket
   */
  sendSessionSettings(sessionSettings) {
    if (!this.socket) {
      throw new Error("Socket is not connected.");
    }
    if (this.socket.readyState !== WebSocket.OPEN) {
      throw new Error("Socket is not open.");
    }
    const snakeCaseSettings = (0, import_snakecase_keys.default)(sessionSettings);
    const json = JSON.stringify({
      ...snakeCaseSettings,
      type: "session_settings"
    });
    this.socket.send(json);
  }
  /**
   * @name sendToolMessage
   * @description
   * Send tool response to the websocket, e.g. for function calling
   */
  sendToolMessage(toolMessage) {
    if (!this.socket) {
      throw new Error("Socket is not connected.");
    }
    if (this.socket.readyState !== WebSocket.OPEN) {
      throw new Error("Socket is not open.");
    }
    const json = JSON.stringify(toolMessage);
    this.socket.send(json);
  }
  /**
   * @name readyState
   * @description
   * The current ready state of the socket.
   */
  get readyState() {
    return this.socket.readyState;
  }
  /**
   * @name sendPauseAssistantMessage
   * @description
   * Send pause assistant message to the websocket. This pauses responses from EVI. Chat history is still saved and sent after resuming.
   */
  sendPauseAssistantMessage() {
    if (!this.socket) {
      throw new Error("Socket is not connected.");
    }
    if (this.socket.readyState !== WebSocket.OPEN) {
      throw new Error("Socket is not open.");
    }
    const json = JSON.stringify({ type: "pause_assistant_message" });
    this.socket.send(json);
  }
  /**
   * @name sendResumeAssistantMessage
   * @description
   * Send resume assistant message to the websocket. This resumes responses from EVI. Chat history sent while paused will now be sent.
   */
  sendResumeAssistantMessage() {
    if (!this.socket) {
      throw new Error("Socket is not connected.");
    }
    if (this.socket.readyState !== WebSocket.OPEN) {
      throw new Error("Socket is not open.");
    }
    const json = JSON.stringify({ type: "resume_assistant_message" });
    this.socket.send(json);
  }
};

// src/lib/create-socket-config.ts
var import_zod14 = require("zod");

// src/models/auth.ts
var import_zod13 = __toESM(require("zod"));
var AuthStrategySchema = import_zod13.default.union([
  import_zod13.default.object({
    type: import_zod13.default.literal("apiKey"),
    value: import_zod13.default.string({
      description: "API key for the Hume API is required"
    })
  }),
  import_zod13.default.object({
    type: import_zod13.default.literal("accessToken"),
    value: import_zod13.default.string({
      description: "Access token for the Hume API is required"
    })
  })
]);

// src/lib/create-socket-config.ts
var SocketConfigSchema = import_zod14.z.object({
  // Configs that are set at connection time
  hostname: import_zod14.z.string({
    description: "Hostname of the Hume API."
  }),
  reconnectAttempts: import_zod14.z.number({
    description: "Number of times to attempt to reconnect to the API."
  }).optional().default(30),
  debug: import_zod14.z.boolean({
    description: "Enable debug mode."
  }).optional().default(false),
  // Configs that are set as query params
  auth: AuthStrategySchema,
  configId: import_zod14.z.string({
    description: "The ID of the configuration to use."
  }).optional(),
  configVersion: import_zod14.z.number({
    description: "The version of the configuration to use."
  }).optional(),
  resumedChatGroupId: import_zod14.z.string({
    description: "The ID of the chat group to resume."
  }).optional()
});
var defaultConfig = {
  hostname: "api.hume.ai",
  reconnectAttempts: 30,
  debug: false
};
var createSocketConfig = (config) => {
  if (!config.auth)
    throw new Error("Auth strategy is required.");
  return SocketConfigSchema.parse({
    ...defaultConfig,
    ...config,
    auth: config.auth
  });
};

// src/lib/tts.ts
var TTSService = /* @__PURE__ */ ((TTSService2) => {
  TTSService2["DEFAULT"] = "hume_ai";
  TTSService2["ELEVEN_LABS"] = "eleven_labs";
  TTSService2["PLAY_HT"] = "play_ht";
  return TTSService2;
})(TTSService || {});

// src/lib/microphone.ts
var getAudioStream = async () => {
  return navigator.mediaDevices.getUserMedia({
    audio: {
      echoCancellation: true,
      noiseSuppression: true,
      autoGainControl: true
    },
    video: false
  });
};
var checkForAudioTracks = (stream) => {
  const tracks = stream.getAudioTracks();
  if (tracks.length === 0) {
    throw new Error("No audio tracks");
  }
  if (tracks.length > 1) {
    throw new Error("Multiple audio tracks");
  }
  const track = tracks[0];
  if (!track) {
    throw new Error("No audio track");
  }
};

// src/lib/fetch-access-token.ts
function base64Encode(str) {
  if (typeof Buffer === "function") {
    return Buffer.from(str).toString("base64");
  } else if (typeof btoa === "function") {
    return btoa(str);
  } else {
    throw new Error(
      "Base64 encoding is not natively supported in this environment."
    );
  }
}
var fetchAccessToken = async (args) => {
  const { apiKey, secretKey, host = "api.hume.ai" } = args;
  const authString = `${apiKey}:${secretKey}`;
  const encoded = base64Encode(authString);
  const res = await fetch(`https://${host}/oauth2-cc/token`, {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      Authorization: `Basic ${encoded}`
    },
    body: new URLSearchParams({
      grant_type: "client_credentials"
    }).toString(),
    cache: "no-cache"
  });
  const data = await res.json();
  const accessToken = String(data["access_token"]);
  return accessToken;
};

// src/models/session-settings.ts
var import_zod15 = __toESM(require("zod"));
var Channels = /* @__PURE__ */ ((Channels2) => {
  Channels2[Channels2["MONO"] = 1] = "MONO";
  Channels2[Channels2["STEREO"] = 2] = "STEREO";
  return Channels2;
})(Channels || {});
var AudioEncoding = /* @__PURE__ */ ((AudioEncoding2) => {
  AudioEncoding2["LINEAR16"] = "linear16";
  AudioEncoding2["OPUS"] = "opus";
  return AudioEncoding2;
})(AudioEncoding || {});
var AudioConfigurationSchema = import_zod15.default.object({
  channels: import_zod15.default.nativeEnum(Channels, {
    description: "Number of channels in the input audio."
  }),
  encoding: import_zod15.default.nativeEnum(AudioEncoding, {
    description: "Encoding of the input audio."
  }),
  sampleRate: import_zod15.default.number({
    description: "Sample rate of the input audio."
  })
});
var ContextConfigurationSchema = import_zod15.default.object({
  text: import_zod15.default.string(),
  type: import_zod15.default.enum(["editable", "persistent", "temporary"]).optional()
});
var WebSearchToolSchema = import_zod15.default.object({
  name: import_zod15.default.literal("web_search"),
  fallback_content: import_zod15.default.string().nullish().catch(null)
});
var SessionSettingsSchema = import_zod15.default.object({
  audio: AudioConfigurationSchema.optional(),
  context: ContextConfigurationSchema.optional(),
  languageModelApiKey: import_zod15.default.string().optional(),
  customSessionId: import_zod15.default.string().optional(),
  systemPrompt: import_zod15.default.string().optional(),
  builtin_tools: import_zod15.default.array(import_zod15.default.union([WebSearchToolSchema, import_zod15.default.null()])).optional()
});

// src/models/llm.ts
var LanguageModelOption = /* @__PURE__ */ ((LanguageModelOption2) => {
  LanguageModelOption2["CLAUDE_3_OPUS"] = "CLAUDE_3_OPUS";
  LanguageModelOption2["CLAUDE_3_SONNET"] = "CLAUDE_3_SONNET";
  LanguageModelOption2["CLAUDE_3_HAIKU"] = "CLAUDE_3_HAIKU";
  LanguageModelOption2["CLAUDE_21"] = "CLAUDE_21";
  LanguageModelOption2["CLAUDE_INSTANT_12"] = "CLAUDE_INSTANT_12";
  LanguageModelOption2["GPT_4_TURBO_PREVIEW"] = "GPT_4_TURBO_PREVIEW";
  LanguageModelOption2["GPT_35_TURBO_0125"] = "GPT_35_TURBO_0125";
  LanguageModelOption2["GPT_35_TURBO"] = "GPT_35_TURBO";
  LanguageModelOption2["FIREWORKS_MIXTRAL_8X7B"] = "FIREWORKS_MIXTRAL_8X7B";
  return LanguageModelOption2;
})(LanguageModelOption || {});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AssistantEndMessageSchema,
  AssistantTranscriptMessageSchema,
  AudioEncoding,
  AudioMessageSchema,
  AudioOutputMessageSchema,
  AuthStrategySchema,
  Channels,
  ChatMetadataMessageSchema,
  EmotionScoresSchema,
  JSONErrorMessageSchema,
  JSONMessageSchema,
  LanguageModelOption,
  MimeType,
  SessionSettingsSchema,
  SocketConfigSchema,
  SocketFailedToParseMessageError,
  SocketUnknownMessageError,
  TTSService,
  TimeSliceSchema,
  ToolCallSchema,
  ToolErrorSchema,
  ToolResponseContentSchema,
  ToolResponseSchema,
  TranscriptModelsSchema,
  UserInterruptionMessageSchema,
  UserTranscriptMessageSchema,
  VoiceClient,
  WebSearchToolSchema,
  arrayBufferToBlob,
  base64ToBlob,
  checkForAudioTracks,
  createSocketConfig,
  createSocketUrl,
  defaultConfig,
  fetchAccessToken,
  getAudioStream,
  getSupportedMimeType,
  isSocketFailedToParseMessageError,
  isSocketUnknownMessageError,
  parseAudioMessage,
  parseMessageData,
  parseMessageType
});
//# sourceMappingURL=index.js.map